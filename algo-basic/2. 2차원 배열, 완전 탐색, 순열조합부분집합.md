# 1. 2차원 배열

## 1) 2차원 배열의 선언

- 2차원 이상의 다차원 배열은 차원에 따라 index를 선언한다.
- 2차원 배열의 선언은 세로길이(행의 개수), 가로길이(열의개수)를 필요로 한다.

ex) int twoDimArr[][] = new int[2][4];      //java에서 배열 객체이므로 new 이용하여 생성해주어야함.

    [int][int][int][int]          => 배열 객체는 총 3개(1차원 두개를 모으고 있는 1차원 하나 형태) 
    [int][int][int][int]             두개의 1차원 배열을 reference로 하는 1차원 배열임. 
                                     ex) new int[2][]; 하면 reference 하는 주소에만 null 들어가고 1*2 형태의 배열은 만들어짐.
                                     ex) arr[0] = new int[3];   arr[1] = new int[2] 해도 OK
    <배열 twoDimArr>

# 2. 2차원 배열의 접근

## 1) 배열 순회
n x m 배열의 n*m 개의 모든 원소를 빠짐없이 조사하는 방법

## 2) 행 우선 순회
    ---------->
    ---------->
    ---------->
행 고정하고 열에 대해 이동하는 구조.

## 3) 열 우선 순회(일반적이진 않음)
    | | | |
    | | | |
    | | | |
    ▽▽▽▽

## 4) 지그재그 순회
    ---------->
    <----------
    ---------->
    <----------

행은 고정하고 열의 방향을 짝수, 홀수별로 다르게 처리함.
for i from 0 to n01
  for j from 0 to m-1
    Array[i][j + (m-1-2*j) * (i%2)];
    // 필요한 연산 수행


## 5) 델타를 이용한 2차 배열 탐색

- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
- 반드시 인덱스 범위 경계 체크 필요함.

        (x-1, y-1)      (x-1, y)        (x-1, y+1)
                            ↑
        (x, y-1)       ←(x, y)→          (x, y+1)
                            ↓
        (x+1, y-1)      (x+1, y)        (x+1, y+1)



        array[0...n-1][0...n-1]
        dx[] <- {-1, 1, 0, 0};      // 상하좌우
        dy[] <- {0, 0, -1, 1};
        => dx, dy 합쳐서 이렇게 쓸수도 있음
        d[] <- { {-1,0}, {1,0}, {0,-1}, {0,1}};

        for x,y from 0 to n-1
          for d from 0 to 3{
              nx <- x + dx[d];
              ny <- y + dy[d];
              array[nx][ny];
           }
        }


# 3. 완전검색(완전탐색, Exhaustive )

## 1) Baby-gin Game

0~9 사이의 숫자 카드에서 임의의 카드 6장 뽑았을때,
연속적인 번호를 갖는 경우            => run
3장의 카드가 동일한 번호를 갖는 경우 => triplet
6장의 카드가 모두 = run + triplet 으로 구성된 경우 => baby-gin

ex)  667767 -> 두개의 triplet -> baby-gin
ex) 054060  -> run + triplet  -> baby-gin
ex) 101123  -> triplet + ?    -> not baby-gin

이런경우 6장의 카드를 정렬을 해서 판단하면 되겠지?
No!
ex) 123123 의 경우, 두개의 run 으로 baby-gin 이지만, 정렬을 하면 112233 으로 not baby-gin

=> 따라서 이런 경우에 모든 경우를 따져보는 완전 탐색이 필요하다!



## 2) 완전 검색(완전 탐색, Exhaustive Search)

- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.
- Brute-force 혹은 generate-and-test 기법.
- 모든 경우의 수 테스트하여 최종해법을 도출 -> 경우의수가 상대적으로 작을때 유리함.
- 상대적으로 빠른 시간안에 문제 해결(알고리즘 설계) 가능
- 모든 경우의 수 생성, 테스트 하기 때문에 수행속도 느리지만, 해답 찾지 못할 확률 ↓
- 문제 풀때 우선 완탐으로 접근하여 해답 도출한 후에, 성능 개선을 위해 다른 알고리즘을 사용하여 해답을 확인하는 것이 바람직함.

- 전형적으로 순열(permutation), 조합(combination), 부분집합(subset)과 같은 조합적 문제들(Combinational Problems)과 연관됨.

- 완탐을 이용한 Baby-gin 접근
- 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함) = 고려할 수 있는 모든 경우의수를 생성 -> 
  앞의 3자리, 뒤의 3자리 잘라서 해답 테스트. 



## 3) 순열, 조합, 부분집합

여행사 BIG SALE!

    <BIG SALE 1> 출발, 도착 선택. 모든 도시를 여행시켜 드립니다. 단 숙박비는 본인 부담. (A,B를 선택했다면 여행사는 어느 경로로 여행할까?)
    A-C-D-E-F-B    
    A-D-C-F-E-B     => 순서에 따라 달라지므로 순열.

    <BIG SALE 2> 3곳을 선택하면 여행시켜 드립니다. (여행자는 어느 도시를 선택할 때 가장 이득일까?)
    - 순서에 상관없이 3곳을 선택하므로 조합.

    <BIG SALE 3> 추가 도시 할인. 2개 선택 10%, 3개 선택 20%, 4개 선택 무려 30% 할인! 단, 이동 경비는 무료입니다. (여행자가 70만원이 있다. 최대 개수의 도시를 선택하려면?)
    - 여행자가 70만원이 있으므로, 하나만 선택해서 70만원일수도, 3개를 선택해서 70만원 일수 있으므로, 부분집합.
    6C1 + 6C2 + 6C3 + 6C4 + 6C5 + 6C6 모든 경우 고려하여 최적 찾아야함



## 4) 순열(Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현

        nPr
        nPr = n! / (n-r)!
        nPn = n!  = n * (n-1) * (n-2) * ... * 2 * 1

- 순서 유의미 -> 순열
- 순서 무의미 -> 조합

- N개의 요소들에 대해서 n! 개의 순열들이 존재함.
- 12! ≒ 약 5억
- 11! ≒ 약 4천만
- 10! ≒ 약 360만
- n > 12 인 경우, 시간 복잡도 폭발적으로 늘어나며, 알고리즘 문제 풀이에서는 사실상 10! 까지만 OK


## 5) 순열 생성하는 방법

- 반복문을 통한 순열 생성

        for i1 from 1 to 3          <- 이 다음에 이전 수들과 비교 해야하는데, 첫 수 뽑았으므로 이전수 없음. pass
            for i2 from 1 to 3
                if i2 != i1 then    <- 이전 수들과 비교
                    for i3 from 1 to 3
                        if i3 != i1 and i3 != i2 then   <- 이전 수(첫번째, 두번째수)들과 비교
                            print i1, i2, i3
                        end if
                    end for
                end if
            end for
        end for

그런데, 더 많은 숫자를 뽑을수록 for 문이 증가함


- 재귀 호출을 통한 순열 생성

        numbers[]: 순열 저장 배열
        isSelected[]: 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
        perm(cnt)   // cnt: 현재까지 뽑은 순열 수의 개수.
            if cnt == 3                     // 기본(기저)파트 : 더이상 재귀적으로 recursive call을 타지 않는 파트. 원하는 만큼 순열을 뽑아냈을때 종료.
                순열 생성 완료
            else
                for i from 1 to 3           // 유도파트 : 계속해서 다음, 다음 순열 만들어냄 
                    if isSelected[i] == true then continue
                    numbers[cnt] <- i
                    isSelected[i] <- true
                    perm(cnt+1)
                    isSelected[i] <- false
                end for



## 6) 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합(combination)이라고 부름

        nCr = n! / (n-r)!r! , (n ≥ r)
        nCr = n-1Cr-1  +  n-1Cr   => 재귀적 표현 
        nC0 = 1

- {1, 2, 3} 세개 중에 두개를 뽑는 조합을 구현한다고 했을때
- (1,2), (1,3), (2,3) 
- 앞에 원소보다 더 큰 원소만 뒤로 뽑는다고 하면 자연스럽게 똑같은 결과 못나오게 제어했기때문에
- 선택 됐는지? 안됐는지? 파악하는 isSelected 배열 없어도 됨.
- 더 간단하게 구현


- 재귀 호출을 이용한 조합 생성 알고리즘

        nCr -> n개의 원소 중 r개 원소를 갖는 조합 생성
        input[]: n개의 원소를 가지고 있는 배열
        numbers[]: r개의 크기의 배열, 조합이 저장될 배열

        comb(cnt, cur)      // cnt: 현재까지 뽑은 조합 원소 개수, cur: 조합에 시도할 원소의 시작 인덱스
            if cnt == r
                조합 생성 완료
            else
                for i from cur to n-1          // 시작하는 인덱스부터 처리함! (뒤에서 더 큰 수만 뽑을거니까) -> 계속 바뀌는 결정 요인 = 매개변수.
                    numbers[cnt] <- input[i];
                    comb(cnt+1, i+1);
                end for
        end comb()


## 7) 순열/조합 응용

    - 주사위 던지기1
    - 주사위를 3번 던져서 나올 수 있는 모든 경우 
        1 1 1
        1 1 2
        ...
        1 2 1
        6 6 5
        6 6 6
    
        => 중복 순열(nπr = n^r)
        6 x 6 x 6 = 216 가지
        
        
        
    - 주사위 던기기2
    - 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우
        1 2 3
        1 2 4
         ...
        1 3 2
         ...
        6 5 3
        6 5 4
     => 순열(permutation)
     6P3
     
     
     
     
     - 주사위 던지기3
     - 주사위를 3번 던진 결과가 중복이 되는 경우를 제외하고 나올 수 있는 모든 경우
        1 1 1
        1 1 2
         ...
        1 1 6
        1 2 2
         ...
        5 6 6
        6 6 6
    => 순서 무의미 but 원소는 중복 가능-> 중복조합 (nHr = n+r-1Cr)
    
    
    
    
    - 주사위 던지기4
    - 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우
        1 2 3
        1 2 4
        1 2 5
        1 2 6
        1 3 4
        1 3 5
         ...
        4 5 6
    => 조합(combination) 


