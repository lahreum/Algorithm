# 1. 리스트(List)

## 1) 리스트
- 순서를 가진 데이터의 집합을 가리키는 추상자료형(abstract data type)
- 동일한 데이터를 가지고 있어도 상관없다.

- 구현 방법에 따라 크게 두 가지로 나뉜다.
  * 순차리스트: 배열을 기반으로 구현된 리스트
  * 연결리스트: 메모리의 동적할당을 기반으로 구현된 리스트
  (java에서의 메모리 동적 할당? new 생성자호출)
  
  
## 2) 순차 리스트

- 구현 방법
  * 1차원 배열에 항목들을 순서대로 저장한다.
  * 데이터의 종류와 구조에 따라 구조화된 자료구조를 만들어 배열로 만들 수도 있다.
  ex) L = {4, 9, 11, 23}    => 한 덩어리인 객체임. 물리적으로 따로 떨어져 있지 X 
           ↑
         offset
 
- 데이터 접근
  * 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 수 있다.
 
- 삽입 연산
  * 삽입 위치 다음의 항목들을 이동해야 한다.
    ex) 2의 위치에 18 삽입
    ex) 4, 9, (18), 11, 23
                    →   →
- 삭제 연산
  * 삭제 위치 다음의 항목들을 이동해야 한다.
    ex) 1의 위치에서 9 삭제
    ex) 4, 18, 11, 23
            ←  ←   ←
        
        
## 3) 순차 리스트의 문제점

- 단순 배열을 이용해 순차리스트를 구현해 사용하는 경우, 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요하다.
- 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가한다.
- 배열의 크기가 정해져 있는 경우, 실제로 사용될 메모리보다 크게 할당하여 메모리의 낭비를 초래할 수도 있고, 반대로 할당된 메모리보다 많은 자료를 사용하여 새롭게 배열을 만들어 작업을 해야 하는 경우가 발생할 수도 있다.


## 4) 연결 리스트(Linked List)  -> 순차 리스트의 단점을 보완한 것

- 특성
 * 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 레퍼런스를 연결하여 하나의 전체적인 자료구조를 이룬다.
 * 링크를 통해 원소에 접근하므로, 순차 리스트에서처럼 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.
 * 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능하다.
 
 ㅁ →  ㅁ →  ㅁ → ㅁ → ...
 객체
 new
 
 
 - 동적으로 계속해서 늘려가는 형태.
 
 ## 5) 연결 리스트의 기본 구조
 
 - 노드
  * 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
  * 구성요소: 데이터 필드(멤버변수. char, Student, Book,... ) 
                   + 
              링크 필드(다음노드와의 연결)

## 6) 단순 연결 리스트(Singly Linked List)

- 연결 구조
 * 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
 * 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
 * 최종적으로 NULL을 가리키는 노드가 리스트의 가장 마지막 노드이다.
 * 연속적인 접근 가능
 
- A, C, D를 원소로 갖고 있는 리스트의 두 번째에 B 노드를 삽입할 때
 (1) 메모리를 할당하여 새로운 노드 new 생성
 (2) 새로운 노드 new의 데이터 필드에 B 저장
 (3) 삽입될 위치의 바로 앞에 위치한 노드의 링크 필드(세번째 주소)를 new에 복사
 (4) new의 주소를 앞 노드의 링크 필드에 저장
 
- 순차 리스트와 다른점? 삭제, 삽입 시 밀어내는 작업 필요 없음.  

       - 첫 번째 노드로 삽입하는 알고리즘 ★★★

       addtoFirst(L,i)         // 리스트 L, 원소i
         new <- createNode();  // 새로운 노드 생성
         new.data = i;         // 데이터 필드 작성
         new.link = L;         // 링크 필드 작성
         L = new;
       end addtoFirst()

- head가 가리키고 있는 애를 나의 링크 필드에 넣으면 쉽게 관리 가능.

      - 가운데 노드로 삽입하는 알고리즘
       * 노드 pre의 다음 위치에 노드 삽입
 
       add(L, pre, i)          // 리스트 L, 노드 pre, 원소 i
          new <- createNode()   // 새로운 노드 생성
          new.data = i;         // 데이터 필드 작성
          if(L = NULL) then {
            L = new;
            new.link = NULL;
          }
          else {
            new.link = pre.link;
            pre.link = new;
          }
       end add()   


      - 마지막 노드로 삽입하는 알고리즘 -> 마지막 노드 찾아야함. 

      addtoLast(L, i)            // 리스트 L, 원소 i
        new <- createNode()      // 새로운 노드 생성
        new.data = i;
        new.link = NULL;
        if(L=NULL) then{         // 빈 리스트일 때, 최초 노드 추가
          L = new;
          return;
        }
        temp = L;
        while(temp.link != NULL) do
          temp = temp.link;
        temp.link = new;
      end addtoLast()  

## 7) 단순 연결 리스트의 삭제 연산

- A,B,C,D 리스트의 B 노드를 삭제할 때

 (1) 삭제할 노드의 앞 노드(선행노드,pre-Node) 탐색
 (2) 삭제할 노드의 링크 필드를 선행노드의 링크 필드에 복사 (링크값을 null로 하는것이 더 좋음 - 가비지 콜렉터 동작할때 더 빨리 gc가 일어남.) 


    - 노드를 삭제하는 알고리즘
     * 노드 pre의 다음 위치에 있는 노드 삭제

    delete(L, pre)     // 리스트 L, 노드 pre
       if(L==NULL) then error;
       else {
         target = pre.link;    // 삭제 노드 지정
         if(target == NULL) then reutnr;
         pre.link = target.link;
       }
       freeNode(target)        // 할당된 메모리 반납
    end delete()   


## 8) 이중 연결 리스트(Doubly Linked List) -> 단순 연결리스트와의 차이점만 정리

- 삭제할 시에 선행(이전)노드 탐색을 빠르게 하기 위해 고안됨.
- 특성
 * 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
 * 두 개의 링크 필드와 한 개의 데이터 필드로 구성
       prev  +   data   +   next
       

