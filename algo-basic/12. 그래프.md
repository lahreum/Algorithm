# 1. 그래프 ★★★★★

- 모든 사물 관계 → 표현가능
- 多 : 多 관계 표현에 용이함

## 1) 그래프

- 그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현한다.
- 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
|V|: 정점의 개수,  |E|: 그래프에 포함된 간선의 개수
|V|개의 정점을 가지는 그래프는 최대 |V|(|V|-1)/2 간선이 가능

ex)       A                한 정점당 가능한 최대 간선수 : 2 , 정점 수 :3
        B   C                 => 3*2 = 6
        

- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기에 용이하다.


## 2) 그래프 유형

- 무향 그래프(Undirected Graph) : 방향 X
- 유향 그래프(Directed Graph) : 방향 O
- 가중치 그래프(Weighted Graph) : 간선 위에 가중치가 있는 그래프 
- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)

*사이클? 한 정점에서 출발해서 다른 정점 거쳐서 다시 자신으로 돌아올 수 있는 형태의 그래프

- 완전 그래프 : 가능한 모든 간선들을 가진 그래프
- 부분 그래프 : 원래 그래프에서 일부 정점이나 간선 제외한 것(like 부분집합)
- 트리는 싸이클이 없는 무향 연결 그래프이다.
  => 한 정점에서 다른 정점으로 가는 루트가 유일함

- 인접(Adjacency) : 두 개의 정점에 간선이 존재하면 서로 인접해 있다고 한다.


## 3) 그래프 경로
- 경로란 간선들을 순서대로 나열한 것
- 경로 중 한 정점을 최대 한 번만 지나는 경로를 단순경로라 한다.
- 시작한 정점에서 끝나는 경로를 사이클(cycle)이라고 한다.
        ex) 1-3-5-1

## 4) 그래프 표현
- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정

- 인접 행렬(Adjacent matrix) : |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장. 배열의 배열
**=> 정점이 적은데 간선이 많은 경우 인접 행렬(정점중심!!!!)**

ex) 정점 10만개인데 간선 2개이면 인접행렬의 많은 공간이 낭비됨. 공간복잡도를 해결하기 위해 나온것이 인접 리스트
ex) 인접한 애들을 찾기 위해서 행렬을 계속해서 탐색해야함.

- 인접 리스트(Adjacent List) : 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
**=> 정점 많은데 간선 적은 경우 인접 리스트(정점중심!!!!)**
ex) 인접관계가 있는 정점, 간선에 대해서만 표현함. 
ex) A-C(1),  B-D/E(2), C- ... 
ex) 리스트의 구성은 10만개(A,B,C,...)를 만들어야 하지만 하나하나 안에는 간선 갯수만 들어있으니까 메모리 공간 측면에서 많이 절약됨.(공간효율)
ex) 인접한 애들만 모아놔서 쭉 리스트 선택하면 인접한 애들만 볼 수 있음. (시간 효율)


- 간선 리스트(Edge List) : 간선(시작 정점, 끝 정점)의 정보를 객체로 표현하여 리스트에 저장
**=> 간선중심!!!!**
ex) A-B, B-C, ... 하나하나의 관계를 하나의 객체로 표현. 

<hr/>


## 2. 인접 행렬

- 두 정점을 연결하는 간선의 유무를 행렬로 표현
- 인접해 있고 가중치 있을때 int로 표현, 인접해 있고 가중치 없을 때 boolean 표현 가능
- 무향: 양방향(arr[0][1] == arr[1][0])
- 유향: 단방향(arr[0][1] != arr[1][0])
- 차수 : 인접 정점의 수
- 진출차수 : 자신으로부터 나가는 선
- 진입차수 : 자신으로 들어오는 선
- 단점: 정점이 v 개면 V x V 개의 셀이 있음. 공간 낭비 多
           


## 3. 인접리스트
- 각 정점에 대한 인접 정점들을 순차적으로 표현
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
- from, to 를 콤팩트하게 표현함


## 4. BFS(Breadth First Search)

- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함.

**시작정점 반드시 큐에 넣고 시작해야함!!!!!**

        BFS(G,v)  //그래프 G, 탐색 시작 정점 v
                큐 생성
                시작 정점 v를 큐에 삽입
                정점 v를 방문한 것으로 표시
                while(큐가 비어있지 않은 경우) {
                         t ← 큐의 첫번째 원소 반환
                         for(t와 연결된 모든 간선에 대해) {
                                u ← 큐의 첫번째 원소 반환       // 큐에서 기다리고 있던 원소 나와~
                                for(t와 연결된 모든 간선에 대해){
                                        u ← t의 인접 정점
                                        u가 방문되지 않은 곳이면,
                                        u를 큐에 넣고, 방문한 것으로 표시
                                }
                        }
                }
        end BFS()


## 5. DFS(Depth First Search)

- 재귀를 사용

                G: 그래프
                DFS(v)  // v:탐색 정점
                        visited[v] ← TRUE       // v 방문 설정

                        FOR each all w in adjacency(G, v)
                                IF visited[w] ≠ TRUE
                                        DFS(w)

















